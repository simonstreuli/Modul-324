# D2: Branching Strategie und Semantic Versioning

## Branching Strategie

### Zielsetzung

Die Branching Strategie dient der strukturierten Zusammenarbeit im Team sowie der Qualitätssicherung des Codes. Sie definiert, wie neue Features, Bugfixes und Releases entwickelt, getestet und in die Hauptentwicklung integriert werden.

### Wahl der Strategie

Wir setzen eine **vereinfachte GitFlow-Strategie** ein, da diese für kleine bis mittlere Projekte geeignet ist. Sie ermöglicht uns:

- eine klare Trennung zwischen stabilen Produktions-Releases und laufender Entwicklung,
- die Integration von Code-Reviews durch Pull Requests,
- die einfache Erweiterung um Continuous Integration (CI) und Continuous Delivery (CD).

### Branch-Typen und Verwendungszweck

| Branch-Typ   | Zweck                                                                                             | Namenskonvention         |
| ------------ | ------------------------------------------------------------------------------------------------- | ------------------------ |
| **main**     | Produktionsbereit, enthält ausschliesslich getestete und freigegebene Versionen.                   | `main`                   |
| **develop**  | Hauptentwicklungszweig. Hier werden Features und Bugfixes integriert.                             | `develop`                |
| **feature/** | Entwicklung neuer Features. Wird von `develop` abgezweigt und dorthin zurückgeführt.              | `feature/<feature-name>` |
| **bugfix/**  | Behebung von Fehlern, die noch nicht produktiv sind. Basis: `develop`.                            | `bugfix/<ticket-id>`     |
| **hotfix/**  | Kritische Fehlerbehebung in der Produktion. Basis: `main`, Rückführung nach `main` und `develop`. | `hotfix/<ticket-id>`     |
| **release/** | Vorbereitung auf ein Release. Enthält letzte Tests und Dokumentationsanpassungen.                 | `release/<version>`      |

### Erlaubte Merge-Wege

- `feature/*` → **merge** nach `develop` (via Pull Request, mit Code Review).
- `bugfix/*` → **merge** nach `develop` (via Pull Request).
- `hotfix/*` → **merge** nach `main` **und** zurück nach `develop`.
- `release/*` → **merge** nach `main` **und** zurück nach `develop`.

### Visualisierung

Die folgende Grafik zeigt den vereinfachten Workflow. Sie erklärt, wie neue Features, Bugfixes, Releases und Hotfixes in verschiedenen Branches entwickelt und dann in die Hauptzweige integriert werden:

```mermaid
gitGraph
   commit id: "Start"
   branch develop
   commit id: "Init develop"

   branch feature/login
   commit id: "Feature: Login erstellt"
   commit id: "Feature: Login erweitert"
   checkout develop
   merge feature/login

   branch bugfix/navbar
   commit id: "Bugfix: Navbar Fix"
   checkout develop
   merge bugfix/navbar

   branch release/1.0.0
   commit id: "Release Vorbereitung"
   checkout main
   merge release/1.0.0
   checkout develop
   merge release/1.0.0

   branch hotfix/789-db-connection
   commit id: "Hotfix: DB Connection"
   checkout main
   merge hotfix/789-db-connection
   checkout develop
   merge hotfix/789-db-connection

```

### Regeln

- **MAJOR**: Inkompatible Änderungen (z. B. API-Bruch, grosse Architekturänderung).
- **MINOR**: Neue Features, die abwärtskompatibel sind.
- **PATCH**: Fehlerbehebungen oder kleine Anpassungen ohne Auswirkungen auf Schnittstellen.

### Zusammenhang mit Branching Strategie

- **release/** Branches tragen die neue geplante Version, z. B. `release/1.2.0`.
- Nach Abschluss wird ein **Tag** auf `main` gesetzt: `v1.2.0`.
- **hotfix/** Branches erzeugen neue **PATCH-Releases**, z. B. `v1.2.1`.

### Anwendungsbeispiele

- Erstes Release: `v1.0.0`  
  → Branch: `release/1.0.0`, Merge nach `main`.

- Neues Feature im Login-Modul: `v1.1.0`  
  → Entwicklung auf `feature/login`, Merge in `develop`, Release mit `release/1.1.0`.

- Kritischer Produktionsbug: `v1.1.1`  
  → Entwicklung auf `hotfix/789-db-connection`, Merge nach `main` und `develop`.
